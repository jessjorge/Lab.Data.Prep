---
title: "Demo"
output: pdf_document
date: "2023-03-30"
---
There's almost certainly a better way to get the files into R, but this is the code I have. 
For most experiments, each subjects will have multiple files; one for each session  (i.e. day).This code creates a list with one element for each subject. Each element of the list contains another list of files, one for each session.
```{r}
library(tidyverse)
library(ggforce)
library(rstatix)
setwd("data")
suffix = ".txt"
prefix = "DF"
subject_numbers = c(21:30)

#===============================================================================
# extracting file names
#===============================================================================

ids = c()
for (s in 1:length(subject_numbers)){
  ids[s] =  paste(toString(subject_numbers[s]),suffix,sep = "")
  ids[s] =  paste(prefix,toString(ids[s]),sep = "")
  ids[s] =  paste0(ids[s], "$")
  }
sub.files = list()



# sort files into file list 

for (s in 1:length(subject_numbers)){
  filenames = list.files(pattern = ids[[s]])
  sub.files[[s]] = list()
  for (f in 1:length(filenames)){sub.files[[s]][[f]]=read.delim(filenames[f])}
  names(sub.files[[s]]) = filenames
}

```


```{r}
df<-mpc(sub.files[[1]],"d")
```



This code creates data frames that now have subject id numbers and group identity. It also assignes ebvent tags to specific variable names. For example, in this case .20 indicates an active lever response occured during normal session time (as opposed to when food was being delivered). It would probably be better to have id assigned based off of the raw data file, as we totally put that in the initial raw file. The tricky thing here is that the variable names are going to vary from lab to lab, project to project. The best thing to feed a function in this case is probably a vector that indicates which event tag belongs to a user specified name. In this case, I am also calculating cumulative measures. This is a common enough thing in the field that it could be useful to include as an option. This code also take forever to run, so maybe something that could be cleaned up. Potentially the best option is a function that would be called for a single event tag that could be called multiple times depending on how many variables of interest there are. The arguments it would take would be the existing data frame to add to, the event tag, and the desired name of the variable. With maybe an option for an additional cumulative version of the variable.
#===============================================================================
# df clean
#===============================================================================
```{r}
##cohort 7
##create list of with binned data frames with # of responses for all subjects

final_d = list()
for(i in 1:length(clean_d)){
  s = clean_d[[i]]
  time_stamp = clean_d[[i]]$time_stamps
    x = data.frame(time_stamp)
      x$id = i
      x$id = as.numeric(x$id)
      x$active_total[1] = (length(s$event_tags[s$event_tags == .25 & s$time_stamps == time_stamp[1]]) + length(s$event_tags[s$event_tags == .20 & s$time_stamps == time_stamp[1]])) 
      x$active_session[1] = length(s$event_tags[s$event_tags == .20 & s$time_stamps == time_stamp[1]])
      x$active_total_cum[1] = x$active_total[1]
      x$active_session_cum[1] = x$active_session[1]
    for(b in 2:length(time_stamp)){
      x$active_total[b] = (length(s$event_tags[s$event_tags == .25 & s$time_stamps == time_stamp[b]])+length(s$event_tags[s$event_tags == .20 & s$time_stamps == time_stamp[b]]))
      x$active_session[b] = length(s$event_tags[s$event_tags == .20 & s$time_stamps == time_stamp[b]])
      x$active_total_cum[b] = x$active_total_cum[b-1] + x$active_total[b]
      x$active_session_cum[b] = x$active_session_cum[b-1] + x$active_session[b]

    }
      final_d[[i]] = x
}
```

I think the best way to handle plotting is to restrict ourselves to 2 types. One that generates a cumulative record from all the code above, and another that deals with the simpler, session wide variables that I don't actually have an example of because we normally do that in excel. So here would be an example of cumulative records. First, the data frames are combined into one giant one that contains all data from all subjects. In this case, the timestamp is converted to hours, which could be an argument to a plotting function. Also, part of this code is selecting colums by colnumber, and that could be different. Probably could have an option to facet based off a grouping variable.
```{r}
library(ggprism)
final_d_df = data.frame()
  for(i in 1:length(final_d)){
final_d_df = rbind(final_d_df, final_d[[i]])
  }

final_d_df = final_d_df %>% 
  pivot_longer(cols = c(3:6),
            names_to = "measure",
             values_to = "value" ) 

final_d_df %>% 
  filter(measure == "active_total_cum") %>% 
  ggplot()+
  geom_step(aes(x = time_stamp/60, y = value, group = id),size = .25)+
  labs(x = "Hours", y = "Cummulative Responses")+
  theme_prism(base_size = 11,base_line_size = 0.30)+
  scale_x_continuous(breaks = c(12, 24, 36, 48, 60, 72, 84),expand = c(0, 0))+ 
  scale_y_continuous(expand = c(0, 0))
```

